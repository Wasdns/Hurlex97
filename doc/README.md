# Hurlex97 开发笔记

## Chapter1

### 知识要求

- 熟悉微机原理和基本的操作系统原理，了解基本的计算机原理概念。

- 了解和熟悉Intel x86保护模式下的一些名词和概念，至少需要熟悉Intel 8086.

- 熟悉和掌握Linux的常用命令，能在Linux下进行基本的系统程序编写。

- 掌握简单的x86汇编语言，能读懂和编写简单的汇编程序（至少能看懂）。

- 熟练掌握C语言程序的编写，对C语言中较为复杂的语法有所了解。

- 理解和掌握C语言程序编译的过程，了解链接的基本原理。

### 工具、环境要求

- Ubuntu 14.04

- qemu

## Chapter2

### 计算机是如何启动的？

[计算机是如何启动的？](http://www.ruanyifeng.com/blog/2013/02/booting.html)

boot的含义

第一阶段：BIOS

- 硬件自检 => BIOS按照"启动顺序"，把控制权转交给排在第一位的储存设备。

第二阶段：主引导记录

- 这时，计算机读取该设备的第一个扇区，也就是读取最前面的512个字节。如果这512个字节的最后两个字节是0x55和0xAA，表明这个设备可以用于启动；如果不是，表明设备不能用于启动，控制权于是被转交给"启动顺序"中的下一个设备。

第三阶段：硬盘启动

计算机的控制权转交给硬盘的某个分区。

有以下情况：

- a.卷引导记录

- b.扩展分区和逻辑分区

- c.启动管理器

在这种情况(c)下，计算机读取"主引导记录"前面446字节的机器码之后，不再把控制权转交给某一个分区，而是运行事先安装的"启动管理器"（boot loader），由用户选择启动哪一个操作系统。

第四阶段：操作系统

- 控制权转交给操作系统后，操作系统的内核首先被载入内存。然后，init线程加载系统的各个模块直至执行/bin/login程序，跳出登录界面，等待用户输入用户名和密码。

### CPU寻址

1.我们的内核使用32位的地址总线来寻址，所以能编址出2的32次方，也就是4G的地址空间;

2.端口统一编址和端口独立编址;

端口统一编址就是把所有和外设存储单元对应的端口直接编址在这4G的地址空间里，当我们对某一个地址进行访问的时候实际上是在访问某个外设的存储单元。

端口独立编址就是说这些端口没有编址在地址空间里，而是另行独立编址。

### CPU在加电后的启动过程

1.CPU重置: CPU进行初始化 => 第一条指令的地址: 0xFFFFFFF0 => 模式化(取指令-翻译指令-执行);

需要在各个阶段提供给CPU相关的数据。

0xFFFFFFF0 指向 BIOS。

2.BIOS POST(硬件自检);

当BIOS找到可启动的设备后，便将该设备的第一个扇区加载到内存的0x7C00地址处，并且跳转过去执行。而我们要做的事情，便是从构造这个可启动的扇区开始。

因为一个扇区只有512字节，放不下太多的代码，所以常规的做法便是在这里写下载入操作系统内核的代码(Bootloader)。

3.Bootloader负责将软硬件的环境设置到一个合适的状态，然后加载操作系统内核并且移交执行权限。

### GRUB

让GRUB加载这个小内核 => 使用GRUB提供的multiboot规范构建操作系统内核。

GRUB规范：[Grub Multiboot规范](http://www.cnblogs.com/chio/archive/2008/01/01/1022430.html)

## Chapter3

### Makefile和ld脚本的简单解释

1.gcc compile .c:

```
C_FLAGS = -c -Wall -m32 -ggdb -gstabs+ -nostdinc -fno-builtin -fno-stack-protector -I include
```

- -m32 是生成32位代码，这样的话我们的开发环境也可以使用64位的Linux系统。

- -ggdb 和-gstabs+ 是添加相关的调试信息，调试对后期的排错很重要。

- -nostdinc 是不包含C语言的标准库里的头文件。

- -fno-builtin 是要求gcc不主动使用自己的内建函数，除非显式声明。

- -fno-stack-protector 是不使用栈保护等检测。

Hint: 后期要加上 `-std=C99` 指明C语言标准。

2.ld

```
LD_FLAGS = -T scripts/kernel.ld -m elf_i386 -nostdlib
```

- -T scripts/kernel.ld 是使用我们自己的链接器脚本。

- -m elf_i386 是生成i386平台下的ELF格式的可执行文件，这是Linux下的可执行文件格式。

- -nostdlib 不链接C语言的标准库。

3.Notes:

- 一个可执行的文件大致由代码段和数据段组成。

- 可执行文件有义务向操作系统提供代码段和数据段位置等信息(置于其组织头部区域)，以便操作系统正确找到它的代码段和数据段并加载执行。

- 不同OS对于executable文件的组织方式不一样，比如Linux的ELF(Executable and Linkable Format)。

- a)按照标准生成规范的Multiboot引导信息 b)使用标准的ELF格式 => 使GRUB把我们的内核正确的加载和执行。

### 启动镜像的制作

文件系统: 文件系统指的是操作系统用于明确磁盘或分区上的文件存储的方法和数据结构，即在磁盘上组织文件的方法。

### 内核的入口和初始化

- Makefile

- boot.s


